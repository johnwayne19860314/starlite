// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: entry.sql

package db

import (
	"context"
)

const createEntry = `-- name: CreateEntry :one
INSERT INTO first.entry (
  entry_code,
  entry_category,
  entry_name,
  entry_amount,
  entry_weight,
  entry_note,
  is_active
) VALUES (
  $1, $2, $3, $4, $5, $6,$7
) RETURNING id, entry_code, entry_category, entry_name, entry_amount, entry_weight, entry_note, is_active, created_at, updated_at
`

type CreateEntryParams struct {
	EntryCode     string
	EntryCategory string
	EntryName     string
	EntryAmount   int32
	EntryWeight   float64
	EntryNote     string
	IsActive      bool
}

func (q *Queries) CreateEntry(ctx context.Context, arg CreateEntryParams) (FirstEntry, error) {
	row := q.db.QueryRow(ctx, createEntry,
		arg.EntryCode,
		arg.EntryCategory,
		arg.EntryName,
		arg.EntryAmount,
		arg.EntryWeight,
		arg.EntryNote,
		arg.IsActive,
	)
	var i FirstEntry
	err := row.Scan(
		&i.ID,
		&i.EntryCode,
		&i.EntryCategory,
		&i.EntryName,
		&i.EntryAmount,
		&i.EntryWeight,
		&i.EntryNote,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type CreateMultipleEntriesParams struct {
	EntryCode     string
	EntryCategory string
	EntryName     string
	EntryAmount   int32
	EntryWeight   float64
	EntryNote     string
	IsActive      bool
}

const deleteEntry = `-- name: DeleteEntry :exec
UPDATE first.entry
SET is_active = false
WHERE entry_code = $1
RETURNING id, entry_code, entry_category, entry_name, entry_amount, entry_weight, entry_note, is_active, created_at, updated_at
`

func (q *Queries) DeleteEntry(ctx context.Context, entryCode string) error {
	_, err := q.db.Exec(ctx, deleteEntry, entryCode)
	return err
}

const getEntry = `-- name: GetEntry :one
SELECT id, entry_code, entry_category, entry_name, entry_amount, entry_weight, entry_note, is_active, created_at, updated_at FROM first.entry
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetEntry(ctx context.Context, id int32) (FirstEntry, error) {
	row := q.db.QueryRow(ctx, getEntry, id)
	var i FirstEntry
	err := row.Scan(
		&i.ID,
		&i.EntryCode,
		&i.EntryCategory,
		&i.EntryName,
		&i.EntryAmount,
		&i.EntryWeight,
		&i.EntryNote,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEntryByCode = `-- name: GetEntryByCode :one
SELECT id, entry_code, entry_category, entry_name, entry_amount, entry_weight, entry_note, is_active, created_at, updated_at FROM first.entry
WHERE entry_code = $1 LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetEntryByCode(ctx context.Context, entryCode string) (FirstEntry, error) {
	row := q.db.QueryRow(ctx, getEntryByCode, entryCode)
	var i FirstEntry
	err := row.Scan(
		&i.ID,
		&i.EntryCode,
		&i.EntryCategory,
		&i.EntryName,
		&i.EntryAmount,
		&i.EntryWeight,
		&i.EntryNote,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEntryByName = `-- name: GetEntryByName :one
SELECT id, entry_code, entry_category, entry_name, entry_amount, entry_weight, entry_note, is_active, created_at, updated_at FROM first.entry
WHERE entry_name = $1 LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetEntryByName(ctx context.Context, entryName string) (FirstEntry, error) {
	row := q.db.QueryRow(ctx, getEntryByName, entryName)
	var i FirstEntry
	err := row.Scan(
		&i.ID,
		&i.EntryCode,
		&i.EntryCategory,
		&i.EntryName,
		&i.EntryAmount,
		&i.EntryWeight,
		&i.EntryNote,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEntrys = `-- name: ListEntrys :many
SELECT id, entry_code, entry_category, entry_name, entry_amount, entry_weight, entry_note, is_active, created_at, updated_at FROM first.entry
WHERE is_active = $1
and entry_category = $4
ORDER BY updated_at desc
LIMIT $2
OFFSET $3
`

type ListEntrysParams struct {
	IsActive      bool
	Limit         int32
	Offset        int32
	EntryCategory string
}

func (q *Queries) ListEntrys(ctx context.Context, arg ListEntrysParams) ([]FirstEntry, error) {
	rows, err := q.db.Query(ctx, listEntrys,
		arg.IsActive,
		arg.Limit,
		arg.Offset,
		arg.EntryCategory,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FirstEntry
	for rows.Next() {
		var i FirstEntry
		if err := rows.Scan(
			&i.ID,
			&i.EntryCode,
			&i.EntryCategory,
			&i.EntryName,
			&i.EntryAmount,
			&i.EntryWeight,
			&i.EntryNote,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEntryAmount = `-- name: UpdateEntryAmount :one
UPDATE first.entry
SET entry_amount = $2
WHERE id = $1
RETURNING id, entry_code, entry_category, entry_name, entry_amount, entry_weight, entry_note, is_active, created_at, updated_at
`

type UpdateEntryAmountParams struct {
	ID          int32
	EntryAmount int32
}

func (q *Queries) UpdateEntryAmount(ctx context.Context, arg UpdateEntryAmountParams) (FirstEntry, error) {
	row := q.db.QueryRow(ctx, updateEntryAmount, arg.ID, arg.EntryAmount)
	var i FirstEntry
	err := row.Scan(
		&i.ID,
		&i.EntryCode,
		&i.EntryCategory,
		&i.EntryName,
		&i.EntryAmount,
		&i.EntryWeight,
		&i.EntryNote,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEntryNote = `-- name: UpdateEntryNote :one
UPDATE first.entry
SET entry_note = $2
WHERE id = $1
RETURNING id, entry_code, entry_category, entry_name, entry_amount, entry_weight, entry_note, is_active, created_at, updated_at
`

type UpdateEntryNoteParams struct {
	ID        int32
	EntryNote string
}

func (q *Queries) UpdateEntryNote(ctx context.Context, arg UpdateEntryNoteParams) (FirstEntry, error) {
	row := q.db.QueryRow(ctx, updateEntryNote, arg.ID, arg.EntryNote)
	var i FirstEntry
	err := row.Scan(
		&i.ID,
		&i.EntryCode,
		&i.EntryCategory,
		&i.EntryName,
		&i.EntryAmount,
		&i.EntryWeight,
		&i.EntryNote,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEntryWeight = `-- name: UpdateEntryWeight :one
UPDATE first.entry
SET entry_weight = $2
WHERE id = $1
RETURNING id, entry_code, entry_category, entry_name, entry_amount, entry_weight, entry_note, is_active, created_at, updated_at
`

type UpdateEntryWeightParams struct {
	ID          int32
	EntryWeight float64
}

func (q *Queries) UpdateEntryWeight(ctx context.Context, arg UpdateEntryWeightParams) (FirstEntry, error) {
	row := q.db.QueryRow(ctx, updateEntryWeight, arg.ID, arg.EntryWeight)
	var i FirstEntry
	err := row.Scan(
		&i.ID,
		&i.EntryCode,
		&i.EntryCategory,
		&i.EntryName,
		&i.EntryAmount,
		&i.EntryWeight,
		&i.EntryNote,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
